# 26. Удаление дубликатов из отсортированного массива

Дан целочисленный массив ```nums```, отсортированный в **неубывающем порядке**.
Удалите дубликаты *"на месте"* таким образом,
чтобы каждый уникальный элемент появлялся в массиве только один раз.
Относительный порядок элементов должен быть сохранён.
Затем верните *количество уникальных элементов в массиве* ```nums```.

Учтите, что количество уникальных элементов в ```nums``` обозначается как ```k```.
Чтобы решение было принято, нужно выполнить следующие действия:

* Измените массив ```nums``` так, чтобы первые ```k``` элементов ```nums```
содержали уникальные элементы в том порядке,
в котором они присутствовали изначально.
Остальные элементы массива ```nums``` не важны, так же как и размер массива.

* Верните ```k```.


## Пользовательский судья:
Судья протестирует ваше решение с помощью следующего кода:

```
java
int[] nums = [...];             // Входной массив
int[] expectedNums = [...];     // Ожидаемый результат правильной длины

int k = removeDuplicates(nums); // Вызов вашей реализации

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}
```
Если все утверждения подтвердятся, то ваше решение будет принято.

## Пример 1:
    Ввод: nums = [1,1,2]
    Вывод: 2, nums = [1,2,_]
    Объяснение: Функция должна вернуть k = 2, при этом первые два элемента nums равны 1 и 2 соответственно.
    Не имеет значения, что находится за пределами возвращаемого k (следовательно, это символы подчёркивания).

## Пример 2:
    Ввод: nums = [0,0,1,1,1,2,2,3,3,4]
    Вывод: 5, nums = [0,1,2,3,4,_,_,_,_,_]
    Объяснение: Функция должна вернуть k = 5, при этом первые пять элементов nums равны 0, 1, 2, 3 и 4 соответственно.
    Не имеет значения, что находится за пределами возвращаемого k (следовательно, это символы подчёркивания).

## Ограничения:
    1 <= nums.length <= 3 * 10⁴
    -100 <= nums[i] <= 100
    Массив nums отсортирован в неубывающем порядке.





